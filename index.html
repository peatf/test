<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frosted Glass 3D Wheel</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background-color: #e6e6e6; /* Light gray background matching the reference */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Wait for Three.js to load
        window.addEventListener('load', function() {
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded');
                return;
            }

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe6e6e6); // Light gray background
            
            // Camera setup
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            
            // Check if OrbitControls is loaded correctly
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error('OrbitControls not loaded, adding a basic rotation to view the model');
                // We'll add a simple rotation animation later if controls aren't available
            } else {
                // Orbit controls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                window.controls = controls; // Store in window for access in animation loop
            }
            
            // Create environment map for reflections
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const envMap = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/Park2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Park2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Park2/posy.jpg',
                'https://threejs.org/examples/textures/cube/Park2/negy.jpg',
                'https://threejs.org/examples/textures/cube/Park2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Park2/negz.jpg'
            ]);
            scene.environment = envMap;
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Spot light for highlighting the frosted material
            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(-5, 5, 5);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.2;
            spotLight.decay = 2;
            spotLight.distance = 50;
            spotLight.castShadow = true;
            scene.add(spotLight);
            
            // Material parameters
            const materialParams = {
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.15,
                transmission: 0.95, // High transmission for glass effect
                thickness: 0.5,     // Thickness of the glass
                clearcoat: 1.0,     // Clear coat for extra shine
                clearcoatRoughness: 0.1,
                envMapIntensity: 1.0,
                reflectivity: 0.2,
                ior: 1.5,           // Index of refraction (glass ~ 1.5)
                specularIntensity: 1.0,
                specularColor: 0xffffff
            };
            
            // Create frosted glass material
            const frostedMaterial = new THREE.MeshPhysicalMaterial({
                color: materialParams.color,
                metalness: materialParams.metalness,
                roughness: materialParams.roughness,
                transmission: materialParams.transmission,
                transparent: true,
                envMap: envMap,
                envMapIntensity: materialParams.envMapIntensity,
                clearcoat: materialParams.clearcoat,
                clearcoatRoughness: materialParams.clearcoatRoughness,
                reflectivity: materialParams.reflectivity,
                ior: materialParams.ior,
                side: THREE.DoubleSide,
                specularIntensity: materialParams.specularIntensity,
                specularColor: new THREE.Color(materialParams.specularColor)
            });
            
            // Create the wheel geometry (torus with custom segments for smoother appearance)
            const wheelParams = {
                radius: 2,
                tube: 0.6,
                radialSegments: 64,
                tubularSegments: 64,
                arc: Math.PI * 2
            };
            
            const torusGeometry = new THREE.TorusGeometry(
                wheelParams.radius,
                wheelParams.tube,
                wheelParams.radialSegments,
                wheelParams.tubularSegments,
                wheelParams.arc
            );
            
            const wheel = new THREE.Mesh(torusGeometry, frostedMaterial);
            wheel.castShadow = true;
            wheel.receiveShadow = true;
            wheel.rotation.x = Math.PI / 2; // Rotate to match the reference
            scene.add(wheel);
            
            // Create text - main title at the top
            createTextMesh("REALIZATION", 0, 1.8, 0, 0.2, 0x888888, -0.02);
            createTextMesh("TOOLKIT", 0, 1.4, 0, 0.2, 0x888888, -0.02);
            
            // Button texts (in 3D positioned around the wheel)
            createButtonMesh("ENROLL\nNOW", -1.5, 0, 0, 0.12);
            createButtonMesh("EXPLORE\nthe\nTOOLKIT", 1.5, 0, 0, 0.12);
            createButtonMesh("FIND your\nTOOLS", 0, -1.5, 0, 0.12);
            
            // Create 3D text function
            function createTextMesh(text, x, y, z, size, color = 0xffffff, depth = 0.03) {
                const loader = new THREE.FontLoader();
                
                // Use a callback to handle the loaded font
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                    const textGeometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: size,
                        height: depth,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.01,
                        bevelSize: 0.005,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    
                    textGeometry.computeBoundingBox();
                    
                    // Center the text
                    const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                    
                    const textMaterial = new THREE.MeshPhysicalMaterial({
                        color: color,
                        metalness: 0.1,
                        roughness: 0.2,
                        transmission: 0.9,
                        transparent: true,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1,
                        envMap: envMap,
                        envMapIntensity: 1.0
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(x + centerOffset, y, z);
                    textMesh.castShadow = true;
                    textMesh.receiveShadow = true;
                    scene.add(textMesh);
                });
            }
            
            // Create button function (creates both the button and its text)
            function createButtonMesh(text, x, y, z, size) {
                // Create button background - a rounded rectangle
                const buttonWidth = 1;
                const buttonHeight = 0.6;
                const buttonRadius = 0.1;
                
                const roundedRectShape = new THREE.Shape();
                
                const x0 = -buttonWidth/2;
                const y0 = -buttonHeight/2;
                const width = buttonWidth;
                const height = buttonHeight;
                const radius = buttonRadius;
                
                roundedRectShape.moveTo(x0, y0 + radius);
                roundedRectShape.lineTo(x0, y0 + height - radius);
                roundedRectShape.quadraticCurveTo(x0, y0 + height, x0 + radius, y0 + height);
                roundedRectShape.lineTo(x0 + width - radius, y0 + height);
                roundedRectShape.quadraticCurveTo(x0 + width, y0 + height, x0 + width, y0 + height - radius);
                roundedRectShape.lineTo(x0 + width, y0 + radius);
                roundedRectShape.quadraticCurveTo(x0 + width, y0, x0 + width - radius, y0);
                roundedRectShape.lineTo(x0 + radius, y0);
                roundedRectShape.quadraticCurveTo(x0, y0, x0, y0 + radius);
                
                const extrudeSettings = {
                    steps: 2,
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.02,
                    bevelOffset: 0,
                    bevelSegments: 5
                };
                
                const buttonGeometry = new THREE.ExtrudeGeometry(roundedRectShape, extrudeSettings);
                
                const buttonMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0.1,
                    roughness: 0.2,
                    transmission: 0.92,
                    transparent: true,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    envMap: envMap,
                    envMapIntensity: 0.8
                });
                
                const buttonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);
                buttonMesh.position.set(x, y, z - 0.05); // Move slightly back
                
                // Adjust rotation based on position
                if (x < 0) { // Left button
                    buttonMesh.rotation.z = 0;
                } else if (x > 0) { // Right button
                    buttonMesh.rotation.z = 0;
                } else if (y < 0) { // Bottom button
                    buttonMesh.rotation.z = 0;
                }
                
                buttonMesh.castShadow = true;
                buttonMesh.receiveShadow = true;
                scene.add(buttonMesh);
                
                // Add text to the button
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                    const lines = text.split('\n');
                    const lineHeight = size * 1.2;
                    
                    // Calculate total height to center vertically
                    const totalHeight = lines.length * lineHeight;
                    const startY = y + totalHeight / 2 - lineHeight / 2;
                    
                    lines.forEach((line, index) => {
                        const textGeometry = new THREE.TextGeometry(line, {
                            font: font,
                            size: size,
                            height: 0.01,
                            curveSegments: 12,
                            bevelEnabled: true,
                            bevelThickness: 0.005,
                            bevelSize: 0.002,
                            bevelOffset: 0,
                            bevelSegments: 3
                        });
                        
                        textGeometry.computeBoundingBox();
                        
                        // Center the text horizontally
                        const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                        
                        const textMaterial = new THREE.MeshPhysicalMaterial({
                            color: 0x888888,
                            metalness: 0.2,
                            roughness: 0.1
                        });
                        
                        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                        textMesh.position.set(x + centerOffset, startY - index * lineHeight, z + 0.05);
                        textMesh.castShadow = true;
                        scene.add(textMesh);
                    });
                });
            }
            
            // Resize handler
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // GUI for tweaking parameters
            const gui = new dat.GUI();
            const materialFolder = gui.addFolder('Material');
            
            materialFolder.addColor(materialParams, 'color').onChange(function(value) {
                frostedMaterial.color.set(value);
            });
            
            materialFolder.add(materialParams, 'metalness', 0, 1).onChange(function(value) {
                frostedMaterial.metalness = value;
            });
            
            materialFolder.add(materialParams, 'roughness', 0, 1).onChange(function(value) {
                frostedMaterial.roughness = value;
            });
            
            materialFolder.add(materialParams, 'transmission', 0, 1).onChange(function(value) {
                frostedMaterial.transmission = value;
            });
            
            materialFolder.add(materialParams, 'clearcoat', 0, 1).onChange(function(value) {
                frostedMaterial.clearcoat = value;
            });
            
            materialFolder.add(materialParams, 'clearcoatRoughness', 0, 1).onChange(function(value) {
                frostedMaterial.clearcoatRoughness = value;
            });
            
            materialFolder.add(materialParams, 'envMapIntensity', 0, 5).onChange(function(value) {
                frostedMaterial.envMapIntensity = value;
            });
            
            materialFolder.add(materialParams, 'ior', 1, 2.333).onChange(function(value) {
                frostedMaterial.ior = value;
            });
            
            materialFolder.open();
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Update controls if available
                if (window.controls) {
                    window.controls.update();
                } else {
                    // Add a simple rotation if controls aren't available
                    camera.position.x = 5 * Math.sin(Date.now() * 0.0005);
                    camera.position.z = 5 * Math.cos(Date.now() * 0.0005);
                    camera.lookAt(0, 0, 0);
                }
                
                // Subtle rotation animation
                wheel.rotation.z += 0.001;
                
                // Render scene
                renderer.render(scene, camera);
            }
            
            animate();
        });
    </script>
</body>
</html>
