<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Wheel</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #cccccc;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: fixed;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">Frosted Glass 3D Wheel - Click and drag to rotate</div>
    
    <!-- Load Three.js from a reliable CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer;
        let wheel;
        
        // Initialize the scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            
            // Renderer with basic settings
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Create the wheel
            createWheel();
            
            // Set up lighting
            setupLights();
            
            // Simple camera controls without OrbitControls
            setupCameraControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
        }
        
        // Create the 3D wheel
        function createWheel() {
            // Wheel dimensions
            const outerRadius = 3;
            const innerRadius = 0.8;
            const thickness = 0.4;
            
            // Create a ring (torus) geometry
            const wheelGeometry = new THREE.TorusGeometry(
                (outerRadius + innerRadius) / 2,  // radius
                (outerRadius - innerRadius) / 2,  // tube radius
                16,  // radial segments
                64   // tubular segments
            );
            
            // Create a glass-like material
            const wheelMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                specular: 0x111111,
                shininess: 100,
                transparent: true,
                opacity: 0.7
            });
            
            // Create the wheel mesh
            wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            scene.add(wheel);
            
            // Add texts using simple planes with textures
            addTextElements();
        }
        
        // Add text elements using simple meshes
        function addTextElements() {
            // Create main title area
            const titleGeometry = new THREE.BoxGeometry(2, 0.7, 0.1);
            const titleMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const titleMesh = new THREE.Mesh(titleGeometry, titleMaterial);
            titleMesh.position.set(0, 0, 0.3);
            wheel.add(titleMesh);
            
            // Create ENROLL NOW button
            const button1Geometry = new THREE.BoxGeometry(0.8, 0.5, 0.1);
            const button1Material = new THREE.MeshPhongMaterial({
                color: 0xeeeeee,
                transparent: true,
                opacity: 0.8
            });
            const button1Mesh = new THREE.Mesh(button1Geometry, button1Material);
            button1Mesh.position.set(-1.8, 0, 0.2);
            wheel.add(button1Mesh);
            
            // Create EXPLORE button
            const button2Geometry = new THREE.BoxGeometry(0.8, 0.6, 0.1);
            const button2Material = button1Material.clone();
            const button2Mesh = new THREE.Mesh(button2Geometry, button2Material);
            button2Mesh.position.set(1.8, 0, 0.2);
            wheel.add(button2Mesh);
            
            // Create FIND button
            const button3Geometry = new THREE.BoxGeometry(1.2, 0.5, 0.1);
            const button3Material = button1Material.clone();
            const button3Mesh = new THREE.Mesh(button3Geometry, button3Material);
            button3Mesh.position.set(0, -2.15, 0.2);
            wheel.add(button3Mesh);
            
            // Add a simple spiral icon (just a small disc)
            const spiralGeometry = new THREE.CircleGeometry(0.1, 32);
            const spiralMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const spiralMesh = new THREE.Mesh(spiralGeometry, spiralMaterial);
            spiralMesh.position.set(0, 0.6, 0.3);
            wheel.add(spiralMesh);
        }
        
        // Set up basic lights
        function setupLights() {
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Secondary fill light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-5, 0, 5);
            scene.add(fillLight);
            
            // Ambient light for global illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
        }
        
        // Simple mouse-based camera controls without using OrbitControls
        function setupCameraControls() {
            let isDragging = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };
            
            document.addEventListener('mousedown', function(e) {
                isDragging = true;
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    // Rotate the wheel based on mouse movement
                    if (wheel) {
                        wheel.rotation.z += deltaMove.x * 0.01;
                        wheel.rotation.x += deltaMove.y * 0.01;
                    }
                }
                
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            });
            
            document.addEventListener('mouseup', function(e) {
                isDragging = false;
            });
            
            // Add touch support
            document.addEventListener('touchstart', function(e) {
                isDragging = true;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (isDragging) {
                    const deltaMove = {
                        x: e.touches[0].clientX - previousMousePosition.x,
                        y: e.touches[0].clientY - previousMousePosition.y
                    };
                    
                    // Rotate the wheel based on touch movement
                    if (wheel) {
                        wheel.rotation.z += deltaMove.x * 0.01;
                        wheel.rotation.x += deltaMove.y * 0.01;
                    }
                    
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
                e.preventDefault();
            });
            
            document.addEventListener('touchend', function(e) {
                isDragging = false;
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Add a very subtle constant rotation
            if (wheel) {
                wheel.rotation.z += 0.001;
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize when window is loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>
