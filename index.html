<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frosted Glass 3D Wheel</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #cccccc;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // FXAA
        const fxaaPass = new ShaderPass(FXAAShader);
        const pixelRatio = renderer.getPixelRatio();
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
        composer.addPass(fxaaPass);

        // Subtle bloom effect
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.2,   // strength
            0.4,   // radius
            0.85   // threshold
        );
        composer.addPass(bloomPass);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Environment map for realistic reflections
        new RGBELoader()
            .load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr', function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                scene.background = new THREE.Color(0xcccccc); // Light gray background
                
                // Create the wheel after environment is loaded
                createWheel();
            });

        // Main function to create the wheel
        function createWheel() {
            // Wheel dimensions
            const outerRadius = 3;
            const innerRadius = 0.8;
            const thickness = 0.4;
            const segments = 128;
            
            // Create ring geometry
            const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, segments);
            
            // Extrude the ring to create a 3D shape
            const extrudeSettings = {
                depth: thickness,
                bevelEnabled: true,
                bevelSegments: 6,
                bevelSize: 0.1,
                bevelThickness: 0.05,
                curveSegments: segments
            };
            
            // Create a shape from the ring geometry
            const shape = new THREE.Shape();
            // Outer circle
            shape.absarc(0, 0, outerRadius, 0, Math.PI * 2, false);
            
            // Inner hole (counter-clockwise)
            const holePath = new THREE.Path();
            holePath.absarc(0, 0, innerRadius, 0, Math.PI * 2, true);
            shape.holes.push(holePath);
            
            // Extrude the shape
            const wheelGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            wheelGeometry.center();
            
            // Create the frosted glass material
            const wheelMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.0,  // Low metalness for glass
                roughness: 0.15, // Slightly rough for frosted effect
                transmission: 0.85, // Transparency level
                thickness: thickness, // Physical thickness for refraction
                envMapIntensity: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.2,
                ior: 1.5, // Glass IOR
                reflectivity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            
            // Create the wheel mesh
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.x = Math.PI / 2; // Rotate to be flat
            scene.add(wheel);
            
            // Load font and create text
            const fontLoader = new FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
                createMainTitle(font, wheel);
                createButtons(font, wheel);
            });
            
            // Add lights
            setupLights();
        }
        
        function createMainTitle(font, wheel) {
            const textOptions = {
                font: font,
                size: 0.28,
                height: 0.05,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            // Main title text "REALIZATION"
            const mainTextGeometry1 = new TextGeometry("REALIZATION", textOptions);
            mainTextGeometry1.center();
            
            const textMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.3,
                clearcoat: 1.0,
                envMapIntensity: 1.0
            });
            
            const mainText1 = new THREE.Mesh(mainTextGeometry1, textMaterial);
            mainText1.position.set(0, 0.15, 0.23);
            wheel.add(mainText1);
            
            // "TOOLKIT" text
            const mainTextGeometry2 = new TextGeometry("TOOLKIT", textOptions);
            mainTextGeometry2.center();
            
            const mainText2 = new THREE.Mesh(mainTextGeometry2, textMaterial);
            mainText2.position.set(0, -0.25, 0.23);
            wheel.add(mainText2);
            
            // Add small spiral icon
            const spiralGeometry = new THREE.TorusKnotGeometry(0.08, 0.02, 100, 16);
            const spiralMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.5,
                clearcoat: 1.0
            });
            const spiral = new THREE.Mesh(spiralGeometry, spiralMaterial);
            spiral.position.set(0, 0.5, 0.23);
            spiral.scale.set(1, 1, 0.5);
            wheel.add(spiral);
        }
        
        function createButtons(font, wheel) {
            const buttonTextOptions = {
                font: font,
                size: 0.15,
                height: 0.03,
                curveSegments: 8,
                bevelEnabled: true,
                bevelThickness: 0.005,
                bevelSize: 0.005,
                bevelOffset: 0,
                bevelSegments: 2
            };
            
            // Create button backgrounds
            const buttonMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.0,
                roughness: 0.2,
                transmission: 0.8,
                clearcoat: 1.0,
                envMapIntensity: 0.8,
                transparent: true,
                opacity: 0.85
            });
            
            // ENROLL NOW button
            createButtonWithText(
                "ENROLL", 
                "NOW",
                -1.8, 0, 
                0.8, 0.5, 
                buttonMaterial, 
                buttonTextOptions, 
                font, 
                wheel
            );
            
            // EXPLORE the TOOLKIT button
            createButtonWithText(
                "EXPLORE", 
                "the\nTOOLKIT",
                1.8, 0, 
                0.8, 0.6, 
                buttonMaterial, 
                buttonTextOptions, 
                font, 
                wheel
            );
            
            // FIND your TOOLS button
            createButtonWithText(
                "FIND your", 
                "TOOLS",
                0, -2.15, 
                1.2, 0.5, 
                buttonMaterial, 
                buttonTextOptions, 
                font, 
                wheel
            );
        }
        
        function createButtonWithText(text1, text2, x, y, width, height, material, textOptions, font, parent) {
            // Create rounded rectangle for button
            const roundedRectShape = new THREE.Shape();
            const radius = 0.15;
            
            roundedRectShape.moveTo(-width/2 + radius, -height/2);
            roundedRectShape.lineTo(width/2 - radius, -height/2);
            roundedRectShape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
            roundedRectShape.lineTo(width/2, height/2 - radius);
            roundedRectShape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
            roundedRectShape.lineTo(-width/2 + radius, height/2);
            roundedRectShape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
            roundedRectShape.lineTo(-width/2, -height/2 + radius);
            roundedRectShape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
            
            const buttonExtrudeSettings = {
                depth: 0.06,
                bevelEnabled: true,
                bevelSegments: 3,
                bevelSize: 0.02,
                bevelThickness: 0.02
            };
            
            const buttonGeometry = new THREE.ExtrudeGeometry(roundedRectShape, buttonExtrudeSettings);
            const button = new THREE.Mesh(buttonGeometry, material);
            button.position.set(x, y, 0.1);
            parent.add(button);
            
            // Add text to button
            if (text1) {
                const textGeo1 = new TextGeometry(text1, textOptions);
                textGeo1.center();
                const textMesh1 = new THREE.Mesh(textGeo1, material.clone());
                textMesh1.material.transmission = 0.2;
                textMesh1.position.set(x, y + (text2 ? 0.12 : 0), 0.2);
                parent.add(textMesh1);
            }
            
            if (text2) {
                let displayText = text2;
                // Handle multiline text
                if (text2.includes('\n')) {
                    const textParts = text2.split('\n');
                    for (let i = 0; i < textParts.length; i++) {
                        const textGeo = new TextGeometry(textParts[i], textOptions);
                        textGeo.center();
                        const textMesh = new THREE.Mesh(textGeo, material.clone());
                        textMesh.material.transmission = 0.2;
                        textMesh.position.set(x, y - 0.12 * i, 0.2);
                        parent.add(textMesh);
                    }
                } else {
                    const textGeo2 = new TextGeometry(text2, textOptions);
                    textGeo2.center();
                    const textMesh2 = new THREE.Mesh(textGeo2, material.clone());
                    textMesh2.material.transmission = 0.2;
                    textMesh2.position.set(x, y - 0.12, 0.2);
                    parent.add(textMesh2);
                }
            }
            
            return button;
        }
        
        function setupLights() {
            // Main directional light (like sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Secondary fill light from opposite side
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-5, 0, 5);
            scene.add(fillLight);
            
            // Bottom light for more reflections
            const bottomLight = new THREE.DirectionalLight(0xffffff, 0.3);
            bottomLight.position.set(0, -5, 0);
            scene.add(bottomLight);
            
            // Ambient light for global illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
        }
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update FXAA pass
            fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
            fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }
        
        animate();
    </script>
</body>
</html>
