<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glass Wheel - Three.js</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #e6e6e6;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="loading">Loading 3D Scene...</div>

  <!-- Load the required libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Wait for everything to load
    window.addEventListener('load', function() {
      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xe6e6e6);
      
      // Camera setup
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Renderer setup
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Lighting setup
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 0.5);
      pointLight.position.set(-3, 3, 3);
      scene.add(pointLight);
      
      // Create the glass material
      const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.1,
        transmission: 0.9,
        transparent: true,
        opacity: 0.8,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        side: THREE.DoubleSide
      });
      
      // Create wheel (torus) geometry
      const wheelGeometry = new THREE.TorusGeometry(1.5, 0.4, 32, 64);
      const wheel = new THREE.Mesh(wheelGeometry, glassMaterial);
      wheel.rotation.x = Math.PI / 2;
      wheel.castShadow = true;
      wheel.receiveShadow = true;
      scene.add(wheel);
      
      // Text locations
      const positions = [
        { id: 'title', position: new THREE.Vector3(0, 1.4, 0), text: 'REALIZATION TOOLKIT', scale: 0.2 },
        { id: 'enroll', position: new THREE.Vector3(-1.5, 0, 0.4), text: 'ENROLL NOW', scale: 0.15 },
        { id: 'explore', position: new THREE.Vector3(1.5, 0, 0.4), text: 'EXPLORE the TOOLKIT', scale: 0.15 },
        { id: 'find', position: new THREE.Vector3(0, -1.5, 0.4), text: 'FIND your TOOLS', scale: 0.15 }
      ];
      
      // Create text with HTML elements
      positions.forEach(item => {
        // Convert 3D position to screen position
        const vector = item.position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
        
        // Create HTML element for text
        const element = document.createElement('div');
        element.style.position = 'absolute';
        element.style.width = 'auto';
        element.style.height = 'auto';
        element.style.backgroundColor = item.id === 'title' ? 'transparent' : 'rgba(255, 255, 255, 0.85)';
        element.style.color = '#333';
        element.style.fontWeight = 'bold';
        element.style.padding = item.id === 'title' ? '5px' : '10px 15px';
        element.style.borderRadius = '10px';
        element.style.transform = 'translate(-50%, -50%)';
        element.style.fontFamily = 'Segoe UI, Arial, sans-serif';
        element.style.fontSize = (item.scale * 100) + '%';
        element.style.textAlign = 'center';
        element.style.zIndex = '100';
        element.style.letterSpacing = '2px';
        element.style.lineHeight = '1.4';
        element.style.boxShadow = item.id === 'title' ? 'none' : '0 3px 10px rgba(0, 0, 0, 0.2)';
        element.style.textTransform = 'uppercase';
        element.innerHTML = item.text.replace(' ', '<br>');
        element.style.left = x + 'px';
        element.style.top = y + 'px';
        element.id = 'text-' + item.id;
        
        // Make buttons clickable
        if (item.id !== 'title') {
          element.style.cursor = 'pointer';
          element.style.transition = 'all 0.2s ease';
          element.addEventListener('mouseover', () => {
            element.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
            element.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.25)';
            element.style.transform = 'translate(-50%, -50%) scale(1.05)';
          });
          element.addEventListener('mouseout', () => {
            element.style.backgroundColor = 'rgba(255, 255, 255, 0.85)';
            element.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.2)';
            element.style.transform = 'translate(-50%, -50%) scale(1)';
          });
          element.addEventListener('click', () => {
            alert(item.text + ' clicked!');
          });
        }
        
        document.body.appendChild(element);
        
        // Store for updating
        item.element = element;
      });
      
      // Function to update text positions when scene changes
      function updateTextPositions() {
        positions.forEach(item => {
          const vector = item.position.clone();
          vector.project(camera);
          
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
          
          item.element.style.left = x + 'px';
          item.element.style.top = y + 'px';
        });
      }
      
      // Handle mouse interaction
      const mouse = new THREE.Vector2();
      let isMouseDown = false;
      let previousMousePosition = { x: 0, y: 0 };
      
      window.addEventListener('mousemove', (e) => {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        if (isMouseDown) {
          const deltaMove = {
            x: e.clientX - previousMousePosition.x,
            y: e.clientY - previousMousePosition.y
          };
          
          wheel.rotation.z += deltaMove.x * 0.01;
          
          previousMousePosition = {
            x: e.clientX,
            y: e.clientY
          };
        } else {
          // Subtle movement based on mouse position when not dragging
          wheel.rotation.y = mouse.x * 0.2;
          wheel.rotation.x = Math.PI / 2 + mouse.y * 0.2;
        }
        
        updateTextPositions();
      });
      
      window.addEventListener('mousedown', (e) => {
        isMouseDown = true;
        previousMousePosition = {
          x: e.clientX,
          y: e.clientY
        };
      });
      
      window.addEventListener('mouseup', () => {
        isMouseDown = false;
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateTextPositions();
      });
      
      // Disable scroll zooming
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
      }, { passive: false });
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        // Gentle rotation
        if (!isMouseDown) {
          wheel.rotation.z += 0.001;
        }
        
        // Render scene
        renderer.render(scene, camera);
      }
      
      // Hide loading when ready
      document.getElementById('loading').style.display = 'none';
      
      // Start animation
      animate();
    });
  </script>
</body>
</html>
